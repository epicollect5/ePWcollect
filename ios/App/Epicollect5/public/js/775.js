"use strict";(self["webpackChunkuk_ac_imperial_epicollect_five_beta"]=self["webpackChunkuk_ac_imperial_epicollect_five_beta"]||[]).push([[775],{8775:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"startInputShims\": function() { return /* binding */ startInputShims; }\n/* harmony export */ });\n/* harmony import */ var _index8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8487);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6587);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst cloneMap = new WeakMap();\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0) => {\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY);\n  }\n  else {\n    removeClone(componentEl, inputEl);\n  }\n};\nconst isFocused = (input) => {\n  return input === input.getRootNode().activeElement;\n};\nconst addClone = (componentEl, inputEl, inputRelativeY) => {\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  const parentEl = inputEl.parentNode;\n  // DOM WRITES\n  const clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  const doc = componentEl.ownerDocument;\n  const tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\n};\nconst removeClone = (componentEl, inputEl) => {\n  const clone = cloneMap.get(componentEl);\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n};\n\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\n  if (!scrollEl || !inputEl) {\n    return () => {\n      return;\n    };\n  }\n  const scrollHideCaret = (shouldHideCaret) => {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n  const onBlur = () => relocateInput(componentEl, inputEl, false);\n  const hideCaret = () => scrollHideCaret(true);\n  const showCaret = () => scrollHideCaret(false);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollStart', hideCaret);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return () => {\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollStart', hideCaret);\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollEnd', showCaret);\n    inputEl.addEventListener('ionBlur', onBlur);\n  };\n};\n\nconst SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';\nconst enableInputBlurring = () => {\n  let focused = true;\n  let didScroll = false;\n  const doc = document;\n  const onScroll = () => {\n    didScroll = true;\n  };\n  const onFocusin = () => {\n    focused = true;\n  };\n  const onTouchend = (ev) => {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n    const active = doc.activeElement;\n    if (!active) {\n      return;\n    }\n    // only blur if the active element is a text-input or a textarea\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    }\n    // if the selected target is the active element, do not blur\n    const tapped = ev.target;\n    if (tapped === active) {\n      return;\n    }\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n    focused = false;\n    // TODO: find a better way, why 50ms?\n    setTimeout(() => {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  };\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(doc, 'ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return () => {\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(doc, 'ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n};\n\nconst SCROLL_ASSIST_SPEED = 0.3;\nconst getScrollData = (componentEl, contentEl, keyboardHeight) => {\n  const itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\n  // compute input's Y values relative to the body\n  const inputTop = inputRect.top;\n  const inputBottom = inputRect.bottom;\n  // compute visible area\n  const visibleAreaTop = contentRect.top;\n  const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\n  // compute safe area\n  const safeAreaTop = visibleAreaTop + 15;\n  const safeAreaBottom = visibleAreaBottom * 0.75;\n  // figure out if each edge of the input is within the safe area\n  const distanceToBottom = safeAreaBottom - inputBottom;\n  const distanceToTop = safeAreaTop - inputTop;\n  // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n  const desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0);\n  // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n  const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  const distance = Math.abs(scrollAmount);\n  const duration = distance / SCROLL_ASSIST_SPEED;\n  const scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount,\n    scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4,\n  };\n};\n\nconst enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  let coord;\n  const touchStart = (ev) => {\n    coord = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.q)(ev);\n  };\n  const touchEnd = (ev) => {\n    // input cover touchend/mouseup\n    if (!coord) {\n      return;\n    }\n    // get where the touchend/mouseup ended\n    const endCoord = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.q)(ev);\n    // focus this input if the pointer hasn't moved XX pixels\n    // and the input doesn't already have focus\n    if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n      // begin the input focus process\n      jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight);\n    }\n  };\n  componentEl.addEventListener('touchstart', touchStart, true);\n  componentEl.addEventListener('touchend', touchEnd, true);\n  return () => {\n    componentEl.removeEventListener('touchstart', touchStart, true);\n    componentEl.removeEventListener('touchend', touchEnd, true);\n  };\n};\nconst jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  if (!contentEl && !footerEl) {\n    return;\n  }\n  const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight);\n  if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\n    // the text input is in a safe position that doesn't\n    // require it to be scrolled into view, just set focus now\n    inputEl.focus();\n    return;\n  }\n  // temporarily move the focus to the focus holder so the browser\n  // doesn't freak out while it's trying to get the input in place\n  // at this point the native text input still does not have focus\n  relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n  inputEl.focus();\n  /**\n   * Relocating/Focusing input causes the\n   * click event to be cancelled, so\n   * manually fire one here.\n   */\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => componentEl.click());\n  if (typeof window !== 'undefined') {\n    let scrollContentTimeout;\n    const scrollContent = async () => {\n      // clean up listeners and timeouts\n      if (scrollContentTimeout !== undefined) {\n        clearTimeout(scrollContentTimeout);\n      }\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.removeEventListener('ionKeyboardDidShow', scrollContent);\n      // scroll the input into place\n      if (contentEl) {\n        await (0,_index8_js__WEBPACK_IMPORTED_MODULE_1__.c)(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);\n      }\n      // the scroll view is in the correct position now\n      // give the native text input focus\n      relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\n      // ensure this is the focused input\n      inputEl.focus();\n    };\n    const doubleKeyboardEventListener = () => {\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.addEventListener('ionKeyboardDidShow', scrollContent);\n    };\n    if (contentEl) {\n      const scrollEl = await (0,_index8_js__WEBPACK_IMPORTED_MODULE_1__.g)(contentEl);\n      /**\n       * scrollData will only consider the amount we need\n       * to scroll in order to properly bring the input\n       * into view. It will not consider the amount\n       * we can scroll in the content element.\n       * As a result, scrollData may request a greater\n       * scroll position than is currently available\n       * in the DOM. If this is the case, we need to\n       * wait for the webview to resize/the keyboard\n       * to show in order for additional scroll\n       * bandwidth to become available.\n       */\n      const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n      if (scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {\n        /**\n         * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n         * after the initial keyboard is shown. This prevents the webview from resizing\n         * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n         */\n        if (inputEl.type === 'password') {\n          // Add 50px to account for the \"Passwords\" bar\n          scrollData.scrollAmount += 50;\n          window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n        }\n        else {\n          window.addEventListener('ionKeyboardDidShow', scrollContent);\n        }\n        /**\n         * This should only fire in 2 instances:\n         * 1. The app is very slow.\n         * 2. The app is running in a browser on an old OS\n         * that does not support Ionic Keyboard Events\n         */\n        scrollContentTimeout = setTimeout(scrollContent, 1000);\n        return;\n      }\n    }\n    scrollContent();\n  }\n};\nconst hasPointerMoved = (threshold, startCoord, endCoord) => {\n  if (startCoord && endCoord) {\n    const deltaX = startCoord.x - endCoord.x;\n    const deltaY = startCoord.y - endCoord.y;\n    const distance = deltaX * deltaX + deltaY * deltaY;\n    return distance > threshold * threshold;\n  }\n  return false;\n};\n\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\nconst enableScrollPadding = (keyboardHeight) => {\n  const doc = document;\n  const onFocusin = (ev) => {\n    setScrollPadding(ev.target, keyboardHeight);\n  };\n  const onFocusout = (ev) => {\n    setScrollPadding(ev.target, 0);\n  };\n  doc.addEventListener('focusin', onFocusin);\n  doc.addEventListener('focusout', onFocusout);\n  return () => {\n    doc.removeEventListener('focusin', onFocusin);\n    doc.removeEventListener('focusout', onFocusout);\n  };\n};\nconst setScrollPadding = (input, keyboardHeight) => {\n  var _a, _b;\n  if (input.tagName !== 'INPUT') {\n    return;\n  }\n  if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n    return;\n  }\n  if (((_b = (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.tagName) === 'ION-SEARCHBAR') {\n    return;\n  }\n  const el = (0,_index8_js__WEBPACK_IMPORTED_MODULE_1__.a)(input);\n  if (el === null) {\n    return;\n  }\n  const timer = el[PADDING_TIMER_KEY];\n  if (timer) {\n    clearTimeout(timer);\n  }\n  if (keyboardHeight > 0) {\n    el.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);\n  }\n  else {\n    el[PADDING_TIMER_KEY] = setTimeout(() => {\n      el.style.setProperty('--keyboard-offset', '0px');\n    }, 120);\n  }\n};\n\nconst INPUT_BLURRING = true;\nconst SCROLL_PADDING = true;\nconst startInputShims = (config) => {\n  const doc = document;\n  const keyboardHeight = config.getNumber('keyboardHeight', 290);\n  const scrollAssist = config.getBoolean('scrollAssist', true);\n  const hideCaret = config.getBoolean('hideCaretOnScroll', true);\n  const inputBlurring = config.getBoolean('inputBlurring', true);\n  const scrollPadding = config.getBoolean('scrollPadding', true);\n  const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n  const hideCaretMap = new WeakMap();\n  const scrollAssistMap = new WeakMap();\n  const registerInput = async (componentEl) => {\n    await new Promise((resolve) => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.c)(componentEl, resolve));\n    const inputRoot = componentEl.shadowRoot || componentEl;\n    const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n    const scrollEl = (0,_index8_js__WEBPACK_IMPORTED_MODULE_1__.a)(componentEl);\n    const footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;\n    if (!inputEl) {\n      return;\n    }\n    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n      const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n      hideCaretMap.set(componentEl, rmFn);\n    }\n    if ((!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {\n      const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight);\n      scrollAssistMap.set(componentEl, rmFn);\n    }\n  };\n  const unregisterInput = (componentEl) => {\n    if (hideCaret) {\n      const fn = hideCaretMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      hideCaretMap.delete(componentEl);\n    }\n    if (scrollAssist) {\n      const fn = scrollAssistMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      scrollAssistMap.delete(componentEl);\n    }\n  };\n  if (inputBlurring && INPUT_BLURRING) {\n    enableInputBlurring();\n  }\n  if (scrollPadding && SCROLL_PADDING) {\n    enableScrollPadding(keyboardHeight);\n  }\n  // Input might be already loaded in the DOM before ion-device-hacks did.\n  // At this point we need to look for all of the inputs not registered yet\n  // and register them.\n  for (const input of inputs) {\n    registerInput(input);\n  }\n  doc.addEventListener('ionInputDidLoad', ((ev) => {\n    registerInput(ev.detail);\n  }));\n  doc.addEventListener('ionInputDidUnload', ((ev) => {\n    unregisterInput(ev.detail);\n  }));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc3NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDb0c7QUFDK0I7O0FBRW5JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsR0FBRyxLQUFLLGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOENBQWdCO0FBQ2xCLEVBQUUsOENBQWdCO0FBQ2xCO0FBQ0E7QUFDQSxJQUFJLDhDQUFtQjtBQUN2QixJQUFJLDhDQUFtQjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRSw4Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4Q0FBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOENBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOENBQUc7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhDQUFnQjtBQUNuRDtBQUNBO0FBQ0EscUJBQXFCLDZDQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUyQiIsInNvdXJjZXMiOlsidnVlLXNvdXJjZTovL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lucHV0LXNoaW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBnIGFzIGdldFNjcm9sbEVsZW1lbnQsIGMgYXMgc2Nyb2xsQnlQb2ludCwgYSBhcyBmaW5kQ2xvc2VzdElvbkNvbnRlbnQgfSBmcm9tICcuL2luZGV4OC5qcyc7XG5pbXBvcnQgeyBhIGFzIGFkZEV2ZW50TGlzdGVuZXIsIGIgYXMgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgciBhcyByYWYsIHEgYXMgcG9pbnRlckNvb3JkLCBjIGFzIGNvbXBvbmVudE9uUmVhZHkgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuXG5jb25zdCBjbG9uZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWxvY2F0ZUlucHV0ID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzaG91bGRSZWxvY2F0ZSwgaW5wdXRSZWxhdGl2ZVkgPSAwKSA9PiB7XG4gIGlmIChjbG9uZU1hcC5oYXMoY29tcG9uZW50RWwpID09PSBzaG91bGRSZWxvY2F0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hvdWxkUmVsb2NhdGUpIHtcbiAgICBhZGRDbG9uZShjb21wb25lbnRFbCwgaW5wdXRFbCwgaW5wdXRSZWxhdGl2ZVkpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJlbW92ZUNsb25lKGNvbXBvbmVudEVsLCBpbnB1dEVsKTtcbiAgfVxufTtcbmNvbnN0IGlzRm9jdXNlZCA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gaW5wdXQgPT09IGlucHV0LmdldFJvb3ROb2RlKCkuYWN0aXZlRWxlbWVudDtcbn07XG5jb25zdCBhZGRDbG9uZSA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgaW5wdXRSZWxhdGl2ZVkpID0+IHtcbiAgLy8gdGhpcyBhbGxvd3MgZm9yIHRoZSBhY3R1YWwgaW5wdXQgdG8gcmVjZWl2ZSB0aGUgZm9jdXMgZnJvbVxuICAvLyB0aGUgdXNlcidzIHRvdWNoIGV2ZW50LCBidXQgYmVmb3JlIGl0IHJlY2VpdmVzIGZvY3VzLCBpdFxuICAvLyBtb3ZlcyB0aGUgYWN0dWFsIGlucHV0IHRvIGEgbG9jYXRpb24gdGhhdCB3aWxsIG5vdCBzY3Jld1xuICAvLyB1cCB0aGUgYXBwJ3MgbGF5b3V0LCBhbmQgZG9lcyBub3QgYWxsb3cgdGhlIG5hdGl2ZSBicm93c2VyXG4gIC8vIHRvIGF0dGVtcHQgdG8gc2Nyb2xsIHRoZSBpbnB1dCBpbnRvIHBsYWNlIChtZXNzaW5nIHVwIGhlYWRlcnMvZm9vdGVycylcbiAgLy8gdGhlIGNsb25lZCBpbnB1dCBmaWxscyB0aGUgYXJlYSBvZiB3aGVyZSBuYXRpdmUgaW5wdXQgc2hvdWxkIGJlXG4gIC8vIHdoaWxlIHRoZSBuYXRpdmUgaW5wdXQgZmFrZXMgb3V0IHRoZSBicm93c2VyIGJ5IHJlbG9jYXRpbmcgaXRzZWxmXG4gIC8vIGJlZm9yZSBpdCByZWNlaXZlcyB0aGUgYWN0dWFsIGZvY3VzIGV2ZW50XG4gIC8vIFdlIGhpZGUgdGhlIGZvY3VzZWQgaW5wdXQgKHdpdGggdGhlIHZpc2libGUgY2FyZXQpIGludmlzaWJsZSBieSBtYWtpbmcgaXQgc2NhbGUoMCksXG4gIGNvbnN0IHBhcmVudEVsID0gaW5wdXRFbC5wYXJlbnROb2RlO1xuICAvLyBET00gV1JJVEVTXG4gIGNvbnN0IGNsb25lZEVsID0gaW5wdXRFbC5jbG9uZU5vZGUoZmFsc2UpO1xuICBjbG9uZWRFbC5jbGFzc0xpc3QuYWRkKCdjbG9uZWQtaW5wdXQnKTtcbiAgY2xvbmVkRWwudGFiSW5kZXggPSAtMTtcbiAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY2xvbmVkRWwpO1xuICBjbG9uZU1hcC5zZXQoY29tcG9uZW50RWwsIGNsb25lZEVsKTtcbiAgY29uc3QgZG9jID0gY29tcG9uZW50RWwub3duZXJEb2N1bWVudDtcbiAgY29uc3QgdHggPSBkb2MuZGlyID09PSAncnRsJyA/IDk5OTkgOiAtOTk5OTtcbiAgY29tcG9uZW50RWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgaW5wdXRFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0eH1weCwke2lucHV0UmVsYXRpdmVZfXB4LDApIHNjYWxlKDApYDtcbn07XG5jb25zdCByZW1vdmVDbG9uZSA9IChjb21wb25lbnRFbCwgaW5wdXRFbCkgPT4ge1xuICBjb25zdCBjbG9uZSA9IGNsb25lTWFwLmdldChjb21wb25lbnRFbCk7XG4gIGlmIChjbG9uZSkge1xuICAgIGNsb25lTWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XG4gICAgY2xvbmUucmVtb3ZlKCk7XG4gIH1cbiAgY29tcG9uZW50RWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICBpbnB1dEVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xufTtcblxuY29uc3QgZW5hYmxlSGlkZUNhcmV0T25TY3JvbGwgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIHNjcm9sbEVsKSA9PiB7XG4gIGlmICghc2Nyb2xsRWwgfHwgIWlucHV0RWwpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gIH1cbiAgY29uc3Qgc2Nyb2xsSGlkZUNhcmV0ID0gKHNob3VsZEhpZGVDYXJldCkgPT4ge1xuICAgIGlmIChpc0ZvY3VzZWQoaW5wdXRFbCkpIHtcbiAgICAgIHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIHNob3VsZEhpZGVDYXJldCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvbkJsdXIgPSAoKSA9PiByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBmYWxzZSk7XG4gIGNvbnN0IGhpZGVDYXJldCA9ICgpID0+IHNjcm9sbEhpZGVDYXJldCh0cnVlKTtcbiAgY29uc3Qgc2hvd0NhcmV0ID0gKCkgPT4gc2Nyb2xsSGlkZUNhcmV0KGZhbHNlKTtcbiAgYWRkRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbFN0YXJ0JywgaGlkZUNhcmV0KTtcbiAgYWRkRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbEVuZCcsIHNob3dDYXJldCk7XG4gIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbFN0YXJ0JywgaGlkZUNhcmV0KTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsRW5kJywgc2hvd0NhcmV0KTtcbiAgICBpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbkJsdXInLCBvbkJsdXIpO1xuICB9O1xufTtcblxuY29uc3QgU0tJUF9TRUxFQ1RPUiA9ICdpbnB1dCwgdGV4dGFyZWEsIFtuby1ibHVyXSwgW2NvbnRlbnRlZGl0YWJsZV0nO1xuY29uc3QgZW5hYmxlSW5wdXRCbHVycmluZyA9ICgpID0+IHtcbiAgbGV0IGZvY3VzZWQgPSB0cnVlO1xuICBsZXQgZGlkU2Nyb2xsID0gZmFsc2U7XG4gIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuICBjb25zdCBvblNjcm9sbCA9ICgpID0+IHtcbiAgICBkaWRTY3JvbGwgPSB0cnVlO1xuICB9O1xuICBjb25zdCBvbkZvY3VzaW4gPSAoKSA9PiB7XG4gICAgZm9jdXNlZCA9IHRydWU7XG4gIH07XG4gIGNvbnN0IG9uVG91Y2hlbmQgPSAoZXYpID0+IHtcbiAgICAvLyBpZiBhcHAgZGlkIHNjcm9sbCByZXR1cm4gZWFybHlcbiAgICBpZiAoZGlkU2Nyb2xsKSB7XG4gICAgICBkaWRTY3JvbGwgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gb25seSBibHVyIGlmIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBhIHRleHQtaW5wdXQgb3IgYSB0ZXh0YXJlYVxuICAgIGlmIChhY3RpdmUubWF0Y2hlcyhTS0lQX1NFTEVDVE9SKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgc2VsZWN0ZWQgdGFyZ2V0IGlzIHRoZSBhY3RpdmUgZWxlbWVudCwgZG8gbm90IGJsdXJcbiAgICBjb25zdCB0YXBwZWQgPSBldi50YXJnZXQ7XG4gICAgaWYgKHRhcHBlZCA9PT0gYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0YXBwZWQubWF0Y2hlcyhTS0lQX1NFTEVDVE9SKSB8fCB0YXBwZWQuY2xvc2VzdChTS0lQX1NFTEVDVE9SKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb2N1c2VkID0gZmFsc2U7XG4gICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXksIHdoeSA1MG1zP1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICAgIGFjdGl2ZS5ibHVyKCk7XG4gICAgICB9XG4gICAgfSwgNTApO1xuICB9O1xuICBhZGRFdmVudExpc3RlbmVyKGRvYywgJ2lvblNjcm9sbFN0YXJ0Jywgb25TY3JvbGwpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXNpbiwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQsIGZhbHNlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGRvYywgJ2lvblNjcm9sbFN0YXJ0Jywgb25TY3JvbGwsIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1c2luLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kLCBmYWxzZSk7XG4gIH07XG59O1xuXG5jb25zdCBTQ1JPTExfQVNTSVNUX1NQRUVEID0gMC4zO1xuY29uc3QgZ2V0U2Nyb2xsRGF0YSA9IChjb21wb25lbnRFbCwgY29udGVudEVsLCBrZXlib2FyZEhlaWdodCkgPT4ge1xuICBjb25zdCBpdGVtRWwgPSBjb21wb25lbnRFbC5jbG9zZXN0KCdpb24taXRlbSxbaW9uLWl0ZW1dJykgfHwgY29tcG9uZW50RWw7XG4gIHJldHVybiBjYWxjU2Nyb2xsRGF0YShpdGVtRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGNvbnRlbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwga2V5Ym9hcmRIZWlnaHQsIGNvbXBvbmVudEVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuaW5uZXJIZWlnaHQpO1xufTtcbmNvbnN0IGNhbGNTY3JvbGxEYXRhID0gKGlucHV0UmVjdCwgY29udGVudFJlY3QsIGtleWJvYXJkSGVpZ2h0LCBwbGF0Zm9ybUhlaWdodCkgPT4ge1xuICAvLyBjb21wdXRlIGlucHV0J3MgWSB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIGJvZHlcbiAgY29uc3QgaW5wdXRUb3AgPSBpbnB1dFJlY3QudG9wO1xuICBjb25zdCBpbnB1dEJvdHRvbSA9IGlucHV0UmVjdC5ib3R0b207XG4gIC8vIGNvbXB1dGUgdmlzaWJsZSBhcmVhXG4gIGNvbnN0IHZpc2libGVBcmVhVG9wID0gY29udGVudFJlY3QudG9wO1xuICBjb25zdCB2aXNpYmxlQXJlYUJvdHRvbSA9IE1hdGgubWluKGNvbnRlbnRSZWN0LmJvdHRvbSwgcGxhdGZvcm1IZWlnaHQgLSBrZXlib2FyZEhlaWdodCk7XG4gIC8vIGNvbXB1dGUgc2FmZSBhcmVhXG4gIGNvbnN0IHNhZmVBcmVhVG9wID0gdmlzaWJsZUFyZWFUb3AgKyAxNTtcbiAgY29uc3Qgc2FmZUFyZWFCb3R0b20gPSB2aXNpYmxlQXJlYUJvdHRvbSAqIDAuNzU7XG4gIC8vIGZpZ3VyZSBvdXQgaWYgZWFjaCBlZGdlIG9mIHRoZSBpbnB1dCBpcyB3aXRoaW4gdGhlIHNhZmUgYXJlYVxuICBjb25zdCBkaXN0YW5jZVRvQm90dG9tID0gc2FmZUFyZWFCb3R0b20gLSBpbnB1dEJvdHRvbTtcbiAgY29uc3QgZGlzdGFuY2VUb1RvcCA9IHNhZmVBcmVhVG9wIC0gaW5wdXRUb3A7XG4gIC8vIGRlc2lyZWRTY3JvbGxBbW91bnQgaXMgdGhlIG5lZ2F0ZWQgZGlzdGFuY2UgdG8gdGhlIHNhZmUgYXJlYSBhY2NvcmRpbmcgdG8gb3VyIGNhbGN1bGF0aW9ucy5cbiAgY29uc3QgZGVzaXJlZFNjcm9sbEFtb3VudCA9IE1hdGgucm91bmQoZGlzdGFuY2VUb0JvdHRvbSA8IDAgPyAtZGlzdGFuY2VUb0JvdHRvbSA6IGRpc3RhbmNlVG9Ub3AgPiAwID8gLWRpc3RhbmNlVG9Ub3AgOiAwKTtcbiAgLy8gb3VyIGNhbGN1bGF0aW9ucyBtYWtlIHNvbWUgYXNzdW1wdGlvbnMgdGhhdCBhcmVuJ3QgYWx3YXlzIHRydWUsIGxpa2UgdGhlIGtleWJvYXJkIGJlaW5nIGNsb3NlZCB3aGVuIGFuIGlucHV0XG4gIC8vIGdldHMgZm9jdXMsIHNvIG1ha2Ugc3VyZSB3ZSBkb24ndCBzY3JvbGwgdGhlIGlucHV0IGFib3ZlIHRoZSB2aXNpYmxlIGFyZWFcbiAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5taW4oZGVzaXJlZFNjcm9sbEFtb3VudCwgaW5wdXRUb3AgLSB2aXNpYmxlQXJlYVRvcCk7XG4gIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoc2Nyb2xsQW1vdW50KTtcbiAgY29uc3QgZHVyYXRpb24gPSBkaXN0YW5jZSAvIFNDUk9MTF9BU1NJU1RfU1BFRUQ7XG4gIGNvbnN0IHNjcm9sbER1cmF0aW9uID0gTWF0aC5taW4oNDAwLCBNYXRoLm1heCgxNTAsIGR1cmF0aW9uKSk7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsQW1vdW50LFxuICAgIHNjcm9sbER1cmF0aW9uLFxuICAgIHNjcm9sbFBhZGRpbmc6IGtleWJvYXJkSGVpZ2h0LFxuICAgIGlucHV0U2FmZVk6IC0oaW5wdXRUb3AgLSBzYWZlQXJlYVRvcCkgKyA0LFxuICB9O1xufTtcblxuY29uc3QgZW5hYmxlU2Nyb2xsQXNzaXN0ID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCkgPT4ge1xuICBsZXQgY29vcmQ7XG4gIGNvbnN0IHRvdWNoU3RhcnQgPSAoZXYpID0+IHtcbiAgICBjb29yZCA9IHBvaW50ZXJDb29yZChldik7XG4gIH07XG4gIGNvbnN0IHRvdWNoRW5kID0gKGV2KSA9PiB7XG4gICAgLy8gaW5wdXQgY292ZXIgdG91Y2hlbmQvbW91c2V1cFxuICAgIGlmICghY29vcmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZ2V0IHdoZXJlIHRoZSB0b3VjaGVuZC9tb3VzZXVwIGVuZGVkXG4gICAgY29uc3QgZW5kQ29vcmQgPSBwb2ludGVyQ29vcmQoZXYpO1xuICAgIC8vIGZvY3VzIHRoaXMgaW5wdXQgaWYgdGhlIHBvaW50ZXIgaGFzbid0IG1vdmVkIFhYIHBpeGVsc1xuICAgIC8vIGFuZCB0aGUgaW5wdXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgZm9jdXNcbiAgICBpZiAoIWhhc1BvaW50ZXJNb3ZlZCg2LCBjb29yZCwgZW5kQ29vcmQpICYmICFpc0ZvY3VzZWQoaW5wdXRFbCkpIHtcbiAgICAgIC8vIGJlZ2luIHRoZSBpbnB1dCBmb2N1cyBwcm9jZXNzXG4gICAgICBqc1NldEZvY3VzKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCk7XG4gICAgfVxuICB9O1xuICBjb21wb25lbnRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCwgdHJ1ZSk7XG4gIGNvbXBvbmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFbmQsIHRydWUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbXBvbmVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaFN0YXJ0LCB0cnVlKTtcbiAgICBjb21wb25lbnRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRW5kLCB0cnVlKTtcbiAgfTtcbn07XG5jb25zdCBqc1NldEZvY3VzID0gYXN5bmMgKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCkgPT4ge1xuICBpZiAoIWNvbnRlbnRFbCAmJiAhZm9vdGVyRWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2Nyb2xsRGF0YSA9IGdldFNjcm9sbERhdGEoY29tcG9uZW50RWwsIChjb250ZW50RWwgfHwgZm9vdGVyRWwpLCBrZXlib2FyZEhlaWdodCk7XG4gIGlmIChjb250ZW50RWwgJiYgTWF0aC5hYnMoc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQpIDwgNCkge1xuICAgIC8vIHRoZSB0ZXh0IGlucHV0IGlzIGluIGEgc2FmZSBwb3NpdGlvbiB0aGF0IGRvZXNuJ3RcbiAgICAvLyByZXF1aXJlIGl0IHRvIGJlIHNjcm9sbGVkIGludG8gdmlldywganVzdCBzZXQgZm9jdXMgbm93XG4gICAgaW5wdXRFbC5mb2N1cygpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB0ZW1wb3JhcmlseSBtb3ZlIHRoZSBmb2N1cyB0byB0aGUgZm9jdXMgaG9sZGVyIHNvIHRoZSBicm93c2VyXG4gIC8vIGRvZXNuJ3QgZnJlYWsgb3V0IHdoaWxlIGl0J3MgdHJ5aW5nIHRvIGdldCB0aGUgaW5wdXQgaW4gcGxhY2VcbiAgLy8gYXQgdGhpcyBwb2ludCB0aGUgbmF0aXZlIHRleHQgaW5wdXQgc3RpbGwgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCB0cnVlLCBzY3JvbGxEYXRhLmlucHV0U2FmZVkpO1xuICBpbnB1dEVsLmZvY3VzKCk7XG4gIC8qKlxuICAgKiBSZWxvY2F0aW5nL0ZvY3VzaW5nIGlucHV0IGNhdXNlcyB0aGVcbiAgICogY2xpY2sgZXZlbnQgdG8gYmUgY2FuY2VsbGVkLCBzb1xuICAgKiBtYW51YWxseSBmaXJlIG9uZSBoZXJlLlxuICAgKi9cbiAgcmFmKCgpID0+IGNvbXBvbmVudEVsLmNsaWNrKCkpO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgc2Nyb2xsQ29udGVudFRpbWVvdXQ7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGNsZWFuIHVwIGxpc3RlbmVycyBhbmQgdGltZW91dHNcbiAgICAgIGlmIChzY3JvbGxDb250ZW50VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxDb250ZW50VGltZW91dCk7XG4gICAgICB9XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICAgIC8vIHNjcm9sbCB0aGUgaW5wdXQgaW50byBwbGFjZVxuICAgICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgICBhd2FpdCBzY3JvbGxCeVBvaW50KGNvbnRlbnRFbCwgMCwgc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQsIHNjcm9sbERhdGEuc2Nyb2xsRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gdGhlIHNjcm9sbCB2aWV3IGlzIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIG5vd1xuICAgICAgLy8gZ2l2ZSB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZm9jdXNcbiAgICAgIHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIGZhbHNlLCBzY3JvbGxEYXRhLmlucHV0U2FmZVkpO1xuICAgICAgLy8gZW5zdXJlIHRoaXMgaXMgdGhlIGZvY3VzZWQgaW5wdXRcbiAgICAgIGlucHV0RWwuZm9jdXMoKTtcbiAgICB9O1xuICAgIGNvbnN0IGRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIHNjcm9sbENvbnRlbnQpO1xuICAgIH07XG4gICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBhd2FpdCBnZXRTY3JvbGxFbGVtZW50KGNvbnRlbnRFbCk7XG4gICAgICAvKipcbiAgICAgICAqIHNjcm9sbERhdGEgd2lsbCBvbmx5IGNvbnNpZGVyIHRoZSBhbW91bnQgd2UgbmVlZFxuICAgICAgICogdG8gc2Nyb2xsIGluIG9yZGVyIHRvIHByb3Blcmx5IGJyaW5nIHRoZSBpbnB1dFxuICAgICAgICogaW50byB2aWV3LiBJdCB3aWxsIG5vdCBjb25zaWRlciB0aGUgYW1vdW50XG4gICAgICAgKiB3ZSBjYW4gc2Nyb2xsIGluIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAgICAgKiBBcyBhIHJlc3VsdCwgc2Nyb2xsRGF0YSBtYXkgcmVxdWVzdCBhIGdyZWF0ZXJcbiAgICAgICAqIHNjcm9sbCBwb3NpdGlvbiB0aGFuIGlzIGN1cnJlbnRseSBhdmFpbGFibGVcbiAgICAgICAqIGluIHRoZSBET00uIElmIHRoaXMgaXMgdGhlIGNhc2UsIHdlIG5lZWQgdG9cbiAgICAgICAqIHdhaXQgZm9yIHRoZSB3ZWJ2aWV3IHRvIHJlc2l6ZS90aGUga2V5Ym9hcmRcbiAgICAgICAqIHRvIHNob3cgaW4gb3JkZXIgZm9yIGFkZGl0aW9uYWwgc2Nyb2xsXG4gICAgICAgKiBiYW5kd2lkdGggdG8gYmVjb21lIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgY29uc3QgdG90YWxTY3JvbGxBbW91bnQgPSBzY3JvbGxFbC5zY3JvbGxIZWlnaHQgLSBzY3JvbGxFbC5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQgPiB0b3RhbFNjcm9sbEFtb3VudCAtIHNjcm9sbEVsLnNjcm9sbFRvcCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogT24gaU9TIGRldmljZXMsIHRoZSBzeXN0ZW0gd2lsbCBzaG93IGEgXCJQYXNzd29yZHNcIiBiYXIgYWJvdmUgdGhlIGtleWJvYXJkXG4gICAgICAgICAqIGFmdGVyIHRoZSBpbml0aWFsIGtleWJvYXJkIGlzIHNob3duLiBUaGlzIHByZXZlbnRzIHRoZSB3ZWJ2aWV3IGZyb20gcmVzaXppbmdcbiAgICAgICAgICogdW50aWwgdGhlIFwiUGFzc3dvcmRzXCIgYmFyIGlzIHNob3duLCBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoYXQgdG8gaGFwcGVuIGZpcnN0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlucHV0RWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgICAgIC8vIEFkZCA1MHB4IHRvIGFjY291bnQgZm9yIHRoZSBcIlBhc3N3b3Jkc1wiIGJhclxuICAgICAgICAgIHNjcm9sbERhdGEuc2Nyb2xsQW1vdW50ICs9IDUwO1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBzaG91bGQgb25seSBmaXJlIGluIDIgaW5zdGFuY2VzOlxuICAgICAgICAgKiAxLiBUaGUgYXBwIGlzIHZlcnkgc2xvdy5cbiAgICAgICAgICogMi4gVGhlIGFwcCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBvbiBhbiBvbGQgT1NcbiAgICAgICAgICogdGhhdCBkb2VzIG5vdCBzdXBwb3J0IElvbmljIEtleWJvYXJkIEV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsQ29udGVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KHNjcm9sbENvbnRlbnQsIDEwMDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNjcm9sbENvbnRlbnQoKTtcbiAgfVxufTtcbmNvbnN0IGhhc1BvaW50ZXJNb3ZlZCA9ICh0aHJlc2hvbGQsIHN0YXJ0Q29vcmQsIGVuZENvb3JkKSA9PiB7XG4gIGlmIChzdGFydENvb3JkICYmIGVuZENvb3JkKSB7XG4gICAgY29uc3QgZGVsdGFYID0gc3RhcnRDb29yZC54IC0gZW5kQ29vcmQueDtcbiAgICBjb25zdCBkZWx0YVkgPSBzdGFydENvb3JkLnkgLSBlbmRDb29yZC55O1xuICAgIGNvbnN0IGRpc3RhbmNlID0gZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZO1xuICAgIHJldHVybiBkaXN0YW5jZSA+IHRocmVzaG9sZCAqIHRocmVzaG9sZDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBQQURESU5HX1RJTUVSX0tFWSA9ICckaW9uUGFkZGluZ1RpbWVyJztcbmNvbnN0IGVuYWJsZVNjcm9sbFBhZGRpbmcgPSAoa2V5Ym9hcmRIZWlnaHQpID0+IHtcbiAgY29uc3QgZG9jID0gZG9jdW1lbnQ7XG4gIGNvbnN0IG9uRm9jdXNpbiA9IChldikgPT4ge1xuICAgIHNldFNjcm9sbFBhZGRpbmcoZXYudGFyZ2V0LCBrZXlib2FyZEhlaWdodCk7XG4gIH07XG4gIGNvbnN0IG9uRm9jdXNvdXQgPSAoZXYpID0+IHtcbiAgICBzZXRTY3JvbGxQYWRkaW5nKGV2LnRhcmdldCwgMCk7XG4gIH07XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1c2luKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1c291dCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzaW4pO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXNvdXQpO1xuICB9O1xufTtcbmNvbnN0IHNldFNjcm9sbFBhZGRpbmcgPSAoaW5wdXQsIGtleWJvYXJkSGVpZ2h0KSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGlmIChpbnB1dC50YWdOYW1lICE9PSAnSU5QVVQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnB1dC5wYXJlbnRFbGVtZW50ICYmIGlucHV0LnBhcmVudEVsZW1lbnQudGFnTmFtZSA9PT0gJ0lPTi1JTlBVVCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCgoX2IgPSAoX2EgPSBpbnB1dC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRhZ05hbWUpID09PSAnSU9OLVNFQVJDSEJBUicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZWwgPSBmaW5kQ2xvc2VzdElvbkNvbnRlbnQoaW5wdXQpO1xuICBpZiAoZWwgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGltZXIgPSBlbFtQQURESU5HX1RJTUVSX0tFWV07XG4gIGlmICh0aW1lcikge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gIH1cbiAgaWYgKGtleWJvYXJkSGVpZ2h0ID4gMCkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KCctLWtleWJvYXJkLW9mZnNldCcsIGAke2tleWJvYXJkSGVpZ2h0fXB4YCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZWxbUEFERElOR19USU1FUl9LRVldID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1rZXlib2FyZC1vZmZzZXQnLCAnMHB4Jyk7XG4gICAgfSwgMTIwKTtcbiAgfVxufTtcblxuY29uc3QgSU5QVVRfQkxVUlJJTkcgPSB0cnVlO1xuY29uc3QgU0NST0xMX1BBRERJTkcgPSB0cnVlO1xuY29uc3Qgc3RhcnRJbnB1dFNoaW1zID0gKGNvbmZpZykgPT4ge1xuICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgY29uc3Qga2V5Ym9hcmRIZWlnaHQgPSBjb25maWcuZ2V0TnVtYmVyKCdrZXlib2FyZEhlaWdodCcsIDI5MCk7XG4gIGNvbnN0IHNjcm9sbEFzc2lzdCA9IGNvbmZpZy5nZXRCb29sZWFuKCdzY3JvbGxBc3Npc3QnLCB0cnVlKTtcbiAgY29uc3QgaGlkZUNhcmV0ID0gY29uZmlnLmdldEJvb2xlYW4oJ2hpZGVDYXJldE9uU2Nyb2xsJywgdHJ1ZSk7XG4gIGNvbnN0IGlucHV0Qmx1cnJpbmcgPSBjb25maWcuZ2V0Qm9vbGVhbignaW5wdXRCbHVycmluZycsIHRydWUpO1xuICBjb25zdCBzY3JvbGxQYWRkaW5nID0gY29uZmlnLmdldEJvb2xlYW4oJ3Njcm9sbFBhZGRpbmcnLCB0cnVlKTtcbiAgY29uc3QgaW5wdXRzID0gQXJyYXkuZnJvbShkb2MucXVlcnlTZWxlY3RvckFsbCgnaW9uLWlucHV0LCBpb24tdGV4dGFyZWEnKSk7XG4gIGNvbnN0IGhpZGVDYXJldE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IHNjcm9sbEFzc2lzdE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IHJlZ2lzdGVySW5wdXQgPSBhc3luYyAoY29tcG9uZW50RWwpID0+IHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gY29tcG9uZW50T25SZWFkeShjb21wb25lbnRFbCwgcmVzb2x2ZSkpO1xuICAgIGNvbnN0IGlucHV0Um9vdCA9IGNvbXBvbmVudEVsLnNoYWRvd1Jvb3QgfHwgY29tcG9uZW50RWw7XG4gICAgY29uc3QgaW5wdXRFbCA9IGlucHV0Um9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIHx8IGlucHV0Um9vdC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpO1xuICAgIGNvbnN0IHNjcm9sbEVsID0gZmluZENsb3Nlc3RJb25Db250ZW50KGNvbXBvbmVudEVsKTtcbiAgICBjb25zdCBmb290ZXJFbCA9ICFzY3JvbGxFbCA/IGNvbXBvbmVudEVsLmNsb3Nlc3QoJ2lvbi1mb290ZXInKSA6IG51bGw7XG4gICAgaWYgKCFpbnB1dEVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghIXNjcm9sbEVsICYmIGhpZGVDYXJldCAmJiAhaGlkZUNhcmV0TWFwLmhhcyhjb21wb25lbnRFbCkpIHtcbiAgICAgIGNvbnN0IHJtRm4gPSBlbmFibGVIaWRlQ2FyZXRPblNjcm9sbChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2Nyb2xsRWwpO1xuICAgICAgaGlkZUNhcmV0TWFwLnNldChjb21wb25lbnRFbCwgcm1Gbik7XG4gICAgfVxuICAgIGlmICgoISFzY3JvbGxFbCB8fCAhIWZvb3RlckVsKSAmJiBzY3JvbGxBc3Npc3QgJiYgIXNjcm9sbEFzc2lzdE1hcC5oYXMoY29tcG9uZW50RWwpKSB7XG4gICAgICBjb25zdCBybUZuID0gZW5hYmxlU2Nyb2xsQXNzaXN0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCwgZm9vdGVyRWwsIGtleWJvYXJkSGVpZ2h0KTtcbiAgICAgIHNjcm9sbEFzc2lzdE1hcC5zZXQoY29tcG9uZW50RWwsIHJtRm4pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5yZWdpc3RlcklucHV0ID0gKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgaWYgKGhpZGVDYXJldCkge1xuICAgICAgY29uc3QgZm4gPSBoaWRlQ2FyZXRNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuICAgICAgaGlkZUNhcmV0TWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxBc3Npc3QpIHtcbiAgICAgIGNvbnN0IGZuID0gc2Nyb2xsQXNzaXN0TWFwLmdldChjb21wb25lbnRFbCk7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICAgIHNjcm9sbEFzc2lzdE1hcC5kZWxldGUoY29tcG9uZW50RWwpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGlucHV0Qmx1cnJpbmcgJiYgSU5QVVRfQkxVUlJJTkcpIHtcbiAgICBlbmFibGVJbnB1dEJsdXJyaW5nKCk7XG4gIH1cbiAgaWYgKHNjcm9sbFBhZGRpbmcgJiYgU0NST0xMX1BBRERJTkcpIHtcbiAgICBlbmFibGVTY3JvbGxQYWRkaW5nKGtleWJvYXJkSGVpZ2h0KTtcbiAgfVxuICAvLyBJbnB1dCBtaWdodCBiZSBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgRE9NIGJlZm9yZSBpb24tZGV2aWNlLWhhY2tzIGRpZC5cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBuZWVkIHRvIGxvb2sgZm9yIGFsbCBvZiB0aGUgaW5wdXRzIG5vdCByZWdpc3RlcmVkIHlldFxuICAvLyBhbmQgcmVnaXN0ZXIgdGhlbS5cbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICByZWdpc3RlcklucHV0KGlucHV0KTtcbiAgfVxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignaW9uSW5wdXREaWRMb2FkJywgKChldikgPT4ge1xuICAgIHJlZ2lzdGVySW5wdXQoZXYuZGV0YWlsKTtcbiAgfSkpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignaW9uSW5wdXREaWRVbmxvYWQnLCAoKGV2KSA9PiB7XG4gICAgdW5yZWdpc3RlcklucHV0KGV2LmRldGFpbCk7XG4gIH0pKTtcbn07XG5cbmV4cG9ydCB7IHN0YXJ0SW5wdXRTaGltcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8775\n")}}]);